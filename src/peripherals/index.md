# Периферия

## Что есть Периферия?

Большинство Микроконтроллеров имеют не только ЦПУ, ОЗУ, или Флеш-память - они содержат кусочки
кремния, которые используются для взаимодействия с системами вне микроконтроллера, как прямое, так и
непрямое взаимодействие с окружающим их миром посредством сенсоров, приводных механизмов,
ли интерфейсов взаимодействия с человеком, таких как дисплей или клавиатура. Общее название
для таких компонентов - Периферия.

Эти периферийные устройства полезны по той причине, что они позволяют разработчику сгрузить часть
работы на них, избежав обработки всего в программе. Так же как разработчик прикладных приложений
перенес бы обработку графики на видеокарту, так embedded разработчики могут перенести части задач
на периферийные устройства, позволяя ЦПУ тратить его такты на более важную работу, или просто ждать,
сохраняя энергию.

Если посмотрите на материнскую плату старомодного домашнего компьютера из 1970-х ли 1980-х
(на самом деле персональные компьютеры прошлого не сильно отличаются от встраиваемых систем
сегодняшнего дня), то ожидаете увидеть:

* Процессор
* Чип ОЗУ
* Чип ПЗУ
* Контроллер ввода/вывода

Чип ОЗУ, чип ПЗУ и контроллер ввода/вывода (периферия этой системы) были бы соединены с процессором
через серию параллельных проводников, известных как 'шина'. Эта шина переносит информацию об адресах,
по которой выбирается, с каким устройством на шине процессор хотел бы общаться, а шина данных
переносит реальные данные. В наших встраиваемых микроконтроллерах применяются те же принципы -
разница лишь в том, что все упаковано в один кусок кремния.

Однако, в отличие от видеокарт, которые обычно имеют Программное API, такое как Vulkan, Metal, или OpenGL, периферия представлена в Микроконтроллере аппаратным интерфейсом, которое отражается на кусок памяти.

## Линейное или Реальное Пространство Памяти

В микроконтроллере, запись каких-то данных в какой-то случайный адрес, такой как `0x4000_0000`
или `0x0000_0000`, также может быть полностью допустимым действием.

On a desktop system, доступ к памяти полностью подконтролем MMU, Диспетчеру Памяти. У этого
компонента две главные сферы ответственности: обеспечивать соблюдение прав доступа к разделам
памяти (предотвращая чтение или изменение одним процессом памяти другого процесса);
и перераспределение сегментов физической памяти на диапазоны виртуальной памяти, используемой программами. Микроконтроллеры обычно не имеют MMU, вместо этого в программах просто используются реальные
физические адреса.

Несмотря на то, что 32-битные микроконтроллеры имеют реальное линейное адресное пространство
начиная с `0x0000_0000` и заканчивая `0xFFFF_FFFF`, они как правило используют несколько сотен килобайт
из этого диапазона для имеющейся в наличии памяти. А значит остается значительный объем адресного
пространства. В предыдущих главах, мы упоминали, что ОЗУ расположено по адресу. Если наше ОЗУ было бы
размером 64 KiB (т.е. имело максимальный адрес 0xFFFF), тогда адреса от `0x2000_0000` до `0x2000_FFFF`
соответствовали бы нашему ОЗУ. Когда мы пишем в переменную, расположенную по адресу `0x2000_1234`,
на самом деле внутри какая-то логика определяет верхнюю часть адреса, (0x2000 в этом примере),
а затем активирует ОЗУ таким образом, что оно может воздействовать на нижнюю часть адреса (0x1234 в этом случае).
На Cortex-M у нас также есть Flash ПЗУ, отраженное в адресном пространстве начиная с адреса `0x0000_0000`
до, скажем, адреса `0x0007_FFFF` (если у нас 512 KiB Flash ПЗУ). Вместо того, чтобы игнорировать
все оставшееся пространство между двумя этими регионами, дизайнеры микроконтроллера отражают
интерфейсы для периферии в определенных позициях в памяти. В конечном итоге все выглядит примерно так:

![](../assets/nrf52-memory-map.png)

[Nordic nRF52832 Datasheet (pdf)]

## Периферия, отраженная в памяти

Взаимодействие с этими периферийными устройствами на первый взгляд простое - записывать правильные данные
по правильным адресам. Например, передача 32-битного слова по последовательному порту, можно осуществить
непосредственной записью 32-битного слова по определенному адресу в памяти. Последовательный Порт
примет и отправит данные автоматически.

Настройка периферийных устройств работает аналогичным образом. Вместо вызова функции настройки периферии
имеется незащищенный участок памяти, который служит аппаратным API. Запишите `0x8000_0000` в Регистр
Настройки Частоты SPI, и порт SPI будет отправлять данные со скоростью 8 мегабит в секунду.
Запишите `0x0200_0000` по тому же адресу, и порт SPI будет отправлять данные на скорости 125 килобит в секунду.
Эти настроечные регистры выглядят немного похоже на это:

![](../assets/nrf52-spi-frequency-register.png)

[Nordic nRF52832 Datasheet (pdf)]

Так сделан интерфейс взаимодествия с оборудованием, неважно какой язык программирования Вы используете,
ассемблер это, C или Rust.

[Nordic nRF52832 Datasheet (pdf)]: http://infocenter.nordicsemi.com/pdf/nRF52832_PS_v1.1.pdf
