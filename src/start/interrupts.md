# Прерывания

Прерывания во многом отличаются от исключений, но работа с ними и их использование
очень похожи и они также обрабатываются таким же контроллером
прерываний. В то время как исключения определены архитектурой Cortex-M,
реализации прерываний всегда специфичны для разработчика (а часто и для чипа),
как в смысле именования, так и функциональности.

Прерывания допускают большую гибкость, которую необходимо учитывать
при попытке использовать их расширенным способом. Мы не будем описывать
все варианты их использования в этой книге, однако рекомендуется помнить следующее:

* Прерывания имеют программируемые приоритеты, которые определяют порядок выполнения их обработчиков
* Прерывания могут накапливаться и вытесняться, например выполнение обработчика прерывания может
быть прервано другим прерыванием с большим приоритетом
* Обычно причина, вызвавшая прерывание должна быть устранена, чтобы недопустить бесконечного
повтора вызова обработчика прерывания

Основные шаги инициализации в рантайме всегда одни и те же:
* Настроить периферию на генерацию запросов прерываний на нужные события
* Установить требуемый приоритет обработчика прерывания в контроллере прерываний
* Активировать обработчик прерывания в контроллере прерываний

Так же как и для исключений, крейт `cortex-m-rt` предоставляет атрибут [`interrupt`]
для описания обработчиков прерываний. Доступные прерывания (и их позиция
в таблице обработчиков прерываний) обычно автоматически генерируются
инструментом `svd2rust` из SVD-описания.

[`interrupt`]: https://docs.rs/cortex-m-rt-macros/0.1.5/cortex_m_rt_macros/attr.interrupt.html

``` rust,ignore
// Обработчик прерывания для прерывания Timer2
#[interrupt]
fn TIM2() {
    // ..
    // Clear reason for the generated interrupt request
}
```

Обработчики прерываний выглядят как обычные функции (не считая отсутствия аргументов)
так же как и обработчики исключений. Однако их нельзя вызывать напрямую из других
частей прошивки из-за специальных преобразований вызовов. Тем не менее возможно
программно сгенерировать запросы на прерывание чтобы перейти в обработчик прерывания.

Так же как и в обработчиках исключений возможно определять `static mut` переменные
внутри обработчиков прерываний для *безопасного* хранения состояний.

``` rust,ignore
#[interrupt]
fn TIM2() {
    static mut COUNT: u32 = 0;

    // `COUNT` имеет тип `&mut u32` и его можно использовать безопасно
    *COUNT += 1;
}
```

Более подробно о продемонстрированном здесь механизме описано в
[разделе о прерываниях][exceptions section].

[exceptions section]: ./exceptions.md
