# Исключения

Исключения и прерывания - аппаратный механизм, благодаря которому процессор
обрабатывает асинхронные события и фатальные ошибки (такие как выполнение
невалидной инструкции). Исключения подразумевают вытеснение программы и задействование
обработчиков исключений, подпрограммы выполняются в ответ на сигнал о срабатывании события.

Крейт `cortex-m-rt` предоставляет атрибут [`exception`] для описания обработчиков прерываний.

[`exception`]: https://docs.rs/cortex-m-rt-macros/latest/cortex_m_rt_macros/attr.exception.html

``` rust,ignore
// Обработчиков прерывания для прерывания SysTick (Системный Таймер)
#[exception]
fn SysTick() {
    // ..
}
```

Если не считать атрибут `exception`, обработчики прерываний выглядят как обычные
функции, но есть еще одно отличие: обработчики `exception` *нельзя* вызвать программно.
Исходя из предыдущего примера, вызов `SysTick();` вызвал бы ошибку компиляции.

Такое поведение четко определено и необходимо для реализации такого свойства:
`static mut` переменные, определенные *внутри* обработчиков `exception`, *безопасны* для использования.

``` rust,ignore
#[exception]
fn SysTick() {
    static mut COUNT: u32 = 0;

    // `COUNT` имеет тип `&mut u32` и его можно безопасно использовать
    *COUNT += 1;
}
```

Как Вы можете знать, использование `static mut` переменных в функции делает ее
[*нереентерабельной*](https://en.wikipedia.org/wiki/Reentrancy_(computing)).
Вызов нереентерабельной функции, прямой или непрямой, - это неопределенное поведение,
будь это вызов из многих обработчиков исключений / прерываний или из
`main` и одного или более обработчиков исключений / прерываний.

Безопасный Rust никогда не должен приводить к неопределенному поведению, поэтому
нереентерабельные функции нужно обозначать как `unsafe`. Мы уже сказали, что
обработчики `exception` могут безопасно использовать `static mut` переменные.
Как это возможно? Это возможно по той причине, что обработчики
`exception` *невозможно* вызвать программно, поэтому повторный вход невозможен.

## Полный пример

В этом примере используется системный таймер для генерации исключения `SysTick`
приблизительно каждую секунду. Обработчик исключени `SysTick` отслеживает сколько раз
он был вызван и записывает это в переменную `COUNT`, а затем печатает переменную
`COUNT` в консоли хоста, используя  semihosting.

> **ПРИМЕЧАНИЕ**: Вы можете запустить этот пример на любом устройстве Cortex-M; можете также запустить его
> на QEMU

```rust,ignore
#![deny(unsafe_code)]
#![no_main]
#![no_std]

extern crate panic_halt;

use core::fmt::Write;

use cortex_m::peripheral::syst::SystClkSource;
use cortex_m_rt::{entry, exception};
use cortex_m_semihosting::{
    debug,
    hio::{self, HStdout},
};

#[entry]
fn main() -> ! {
    let p = cortex_m::Peripherals::take().unwrap();
    let mut syst = p.SYST;

    // настраивает системный таймер на генерации исключения SysTick каждую секунду
    syst.set_clock_source(SystClkSource::Core);
    // эта настройка для LM3S6965, у которого тактавая частота по умолчанию 12 МГц
    syst.set_reload(12_000_000);
    syst.enable_counter();
    syst.enable_interrupt();

    loop {}
}

#[exception]
fn SysTick() {
    static mut COUNT: u32 = 0;
    static mut STDOUT: Option<HStdout> = None;

    *COUNT += 1;

    // Ленивая инициализация
    if STDOUT.is_none() {
        *STDOUT = hio::hstdout().ok();
    }

    if let Some(hstdout) = STDOUT.as_mut() {
        write!(hstdout, "{}", *COUNT).ok();
    }

    // ВАЖНО уберите этот блок `if`, если запускаете на реальном оборудовании
    // иначе Ваш отладчик перейдет в нестабильное состояние
    if *COUNT == 9 {
        // This will terminate the QEMU process
        debug::exit(debug::EXIT_SUCCESS);
    }
}
```

``` console
$ tail -n5 Cargo.toml
```

``` toml
[dependencies]
cortex-m = "0.5.7"
cortex-m-rt = "0.6.3"
panic-halt = "0.2.0"
cortex-m-semihosting = "0.3.1"
```

``` console
$ cargo run --release
     Running `qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb (..)
123456789
```

Если запустите этот код на плате Discovery, то увидете вывод в консоли OpenOCD.
К тому же программа *не* остановится, когда счетчик достигнет 9.

## Обработчик исключения по умолчанию

На самом деле атрибут `exception` *переписывает* о бработчик исключения по умолчанию
для конкретного исключения. Если вы этого не сделаете, исключение будет обработано
функцией `DefaultHandler`, которая по умолчанию выглядит так:

``` rust,ignore
fn DefaultHandler() {
    loop {}
}
```

Эта функция предоставляется крейтом `cortex-m-rt` и помечена атрибутом
`#[no_mangle]`, поэтому Вы можете установить точку останова на "DefaultHandler" и словить
*необрабатываемые* исключения.

Есть способ переопределить `DefaultHandler` с помощью атрибута `exception`:

``` rust,ignore
#[exception]
fn DefaultHandler(irqn: i16) {
    // поведение для обработчика по умолчанию
}
```

Аргумент `irqn` показывает, какое именно исключение обрабатыается. Отрицательное
значение сигнализирует о том, что это исключение ядра Cortex-M;
0 ли положительное значение соответствуют обработке устройсво-специфичных исключений,
таких как прерывания.

## Обработчик критической ошибки

Исключение `HardFault` немного особенное. Это исключение возникает, когда
программа входит в невалидное состояние, поэтому такой обработчие *не* должен завершиться,
так как это приведет к неопределенному поведению. Кроме того runtime крейт выполняет
дополнительную работу до вызова пользовательского обработчика `HardFault`,
чтобы упростить отладку.

Как итог, обработчик `HardFault` должен иметь следующую сигнатуру:
`fn(&ExceptionFrame) -> !`. Аргумент обработчика - указатель на регистры,
которые были добавлены в стек исключением. Эти регистры - снимок состояния процессора
в момент возникновения исключения, они полезны для обнаружения критической ошибки.

Вот пример, в котором выполняется запрещенная операция: чтение по несуществующему
адресу памяти.

> **ПРИМЕЧАНИЕ**: Эта программа не заработает, точнее она не сломается на QEMU, потому что
> `qemu-system-arm -machine lm3s6965evb` не осуществляет проверку загрузок в память, и
> вернет `0 ` при чтение из несуществующей памяти.

```rust,ignore
#![no_main]
#![no_std]

extern crate panic_halt;

use core::fmt::Write;
use core::ptr;

use cortex_m_rt::{entry, exception, ExceptionFrame};
use cortex_m_semihosting::hio;

#[entry]
fn main() -> ! {
    // чтение по несуществующему адресу памяти
    unsafe {
        ptr::read_volatile(0x3FFF_FFFE as *const u32);
    }

    loop {}
}

#[exception]
fn HardFault(ef: &ExceptionFrame) -> ! {
    if let Ok(mut hstdout) = hio::hstdout() {
        writeln!(hstdout, "{:#?}", ef).ok();
    }

    loop {}
}
```

Обработчик `HardFault` напечатает значение `ExceptionFrame`. Если Вы запустите этот код,
то увидите что-то подобное этому в консоли OpenOCD.

``` console
$ openocd
(..)
ExceptionFrame {
    r0: 0x3ffffffe,
    r1: 0x00f00000,
    r2: 0x20000000,
    r3: 0x00000000,
    r12: 0x00000000,
    lr: 0x080008f7,
    pc: 0x0800094a,
    xpsr: 0x61000000
}
```

Значение `pc` - значение Программного Счетчика в момент исключения, оно указывает на
инструкцию, вызвавшую исключение.

Если посмотрите на дизассемблированную программу:


``` console
$ cargo objdump --bin app --release -- -d -no-show-raw-insn -print-imm-hex
(..)
ResetTrampoline:
 8000942:       movw    r0, #0xfffe
 8000946:       movt    r0, #0x3fff
 800094a:       ldr     r0, [r0]
 800094c:       b       #-0x4 <ResetTrampoline+0xa>
```

можете найти значение программного счетчика `0x0800094a` в дизассемблированном коде.
И увидете, что операция загрузки (`ldr r0, [r0]` ) вызвала исключение.
Поле `r0` фрейма `ExceptionFrame`, скажет Вам, что значение регистра `r0`
в этот момент было `0x3fff_fffe`.
