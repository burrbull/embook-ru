# Memory Mapped Registers

Встраиваемые системы пока что могли только выполнять обычный Rust код и перемещать данные в ОЗУ.
Если мы хотим передать какую-либо информацию в нашу систему или из нее (будь то мигание светодиода, определение нажатия кнопки или связь с внешним устройством по некоторой шине), нам придется погрузиться в мир Периферийных устройств и их «регистров, отраженных в памяти».

Вы можете обнаружить, что код, необходимый для доступа к периферии в вашем микроконтроллере, уже написан на одном из следующих уровней:

* Крейт микроархитектуры - Этот вид библиотек работает с любыми полезными процедурами, общими для процессорного ядра, используемого вашим микроконтроллером, а также любой периферией, которая является общей для всех микроконтроллеров, использующих этот конкретный тип процессорного ядра. Например, крейт [cortex-m]
предоставляет Вам функции для включения/отключения прерываний, которые одинаковы для всех микроконтроллеров семейства Cortex-M. Он также дает Вам доступ к переферийному устройству 'SysTick', имеющемуся во всех
микроконтроллерах Cortex-M.
* Крейт доступа к периферии (PAC) - Этот вид библиотек - тонкая обертка над множеством отраженных в памяти
регистров, определенных для конкретной группы микроконтоллеров. Например, [tm4c123x] для серии Texas Instruments Tiva-C TM4C123, или [stm32f30x] для серии ST-Micro STM32F30x. С помощью него Вы можете взаимодействовать
с регистрами напрямую, следуя инструкциям по эксплуатации каждого периферийного устройства, приведенным в Техническом справочном руководстве (Technical Reference Manual) вашего микроконтроллера.
* HAL-крейт - Такие библиотеки предлагают более удобный для пользователя API для Вашего конкретного
процессора, часто реализуя некоторые общие типажи, определенные в [embedded-hal]. В качестве примера
этот крейт может предложить структуру `Serial` с конструктором, который принимает подходящий
набор пинов GPIO и скорость передачи данных, и предлагает что-то подобное функции `write_byte` для передачи данных. Смотрите раздел [Переносимость] для большей информации по [embedded-hal].
* Крейт платы - Эти крейты идут на шаг дальше, чем HAL-крейты путем предварительной настройки различных периферийных устройств и выводов GPIO в соответствии с конкретным комплектом разработчика или платой,
которую вы используете, например [F3] для платы STM32F3DISCOVERY.

[cortex-m]: https://crates.io/crates/cortex-m
[tm4c123x]: https://crates.io/crates/tm4c123x
[stm32f30x]: https://crates.io/crates/stm32f30x
[embedded-hal]: https://crates.io/crates/embedded-hal
[Переносимость]: ../portability/index.md
[F3]: https://crates.io/crates/f3


## Начнем снизу

Давайте взглянем на периферийное устройство SysTick, которое общее для всех микроконтроллеров Cortex-M.
Мы можем найти низкоуроневое API в крейте [cortex-m], и использовать его следующим образом:

```rust,ignore
use cortex_m::peripheral::{syst, Peripherals};
use cortex_m_rt::entry;

#[entry]
fn main() -> ! {
    let mut peripherals = Peripherals::take().unwrap();
    let mut systick = peripherals.SYST;
    systick.set_clock_source(syst::SystClkSource::Core);
    systick.set_reload(1_000);
    systick.clear_current();
    systick.enable_counter();
    while !systick.has_wrapped() {
        // Loop
    }

    loop {}
}
```

Методы структуры `SYST` очень похожы на функциональность, определенную Техническим справочным руководством ARM
для этой периферии. В этом API нет ничего подобного 'ждать X милисекунд' - мы должны реализовать это сами грубо,
используя цикл `while`. Заметьте, что мы не можем получить доступ к структуре `SYST`, пока не вызвали
`Peripherals::take()` - это специальная операция, которая гарантирует, что имеется только одна структура
`SYST` во всей программе. Более подробно об этом, см. раздел [Периферия].

[Периферия]: ../peripherals/index.md

## Использование Крейта доступа к периферии (PAC)

Мы не продвинемся далеко в разработке embedded приложений, если ограничим себя только базовой периферией,
включенной в каждый Cortex-M. В какой-то момент нам понадобится написать код, специфичный для определенного
микроконтроллера, который мы используем. Давайте в этом примере представим, что у нас есть Texas Instruments TM4C123 - средненький 80MHz Cortex-M4 с 256 KiB Flash. Мы собираемся подключить крейт [tm4c123x], чтобы
использовать этот чип.

```rust,ignore
#![no_std]
#![no_main]

extern crate panic_halt; // panic handler

use cortex_m_rt::entry;
use tm4c123x;

#[entry]
pub fn init() -> (Delay, Leds) {
    let cp = cortex_m::Peripherals::take().unwrap();
    let p = tm4c123x::Peripherals::take().unwrap();

    let pwm = p.PWM0;
    pwm.ctl.write(|w| w.globalsync0().clear_bit());
    // Mode = 1 => Count up/down mode
    pwm._2_ctl.write(|w| w.enable().set_bit().mode().set_bit());
    pwm._2_gena.write(|w| w.actcmpau().zero().actcmpad().one());
    // 528 cycles (264 up and down) = 4 loops per video line (2112 cycles)
    pwm._2_load.write(|w| unsafe { w.load().bits(263) });
    pwm._2_cmpa.write(|w| unsafe { w.compa().bits(64) });
    pwm.enable.write(|w| w.pwm4en().set_bit());
}

```

Мы получили доступ к периферии `PWM0` в точности тем же способом, как получили доступ к `SYST` ранее,
за исключением того, что вызвали `tm4c123x::Peripherals::take()`. Так как этот крейт был автоматически
сгенерирован с помощью [svd2rust], функции доступа к нашим регистрам принимают замыкание вместо
числового значения. Несмотря на то, что код выглядит немного избыточно, компилятор Rust может использовать его,
чтобы провести ряд проверок для нас, а потом сформировать машинный код, который будет очень похож на
самописный ассемблер! Когда автоматически сгенерированный код не может определить допустимость всех возможных аргументов для определенной функции доступа (например, если SVD определяет регистр как 32-битный, но не говорит, имеют ли некоторые из этих 32-битных значений имеет особое предназначение), то функция помечается как небезопасная (`unsafe`). Мы можем видеть это в примере выше, когда устанавливаем поля `load` и` compa` с помощью функции `bits()`.

### Чтение

Функция `read()` возвраает объект, который предоставляет доступ только для чтения к различным полям
регистра, как определено в SVD-файле производителя чипа. Вы можете найти все функции, доступные в
специальном возвращаемом типе `R` для конкретного регистра конкретной периферии конкретного чипа в
[документации по tm4c123x][tm4c123x documentation R].

```rust,ignore
if pwm.ctl.read().globalsync0().is_set() {
    // Do a thing
}
```

### Запись

Функция `write()` берет замыкание с одним аргументом. Обычно мы называем его `w`. Этот аргумент предоставляет
доступ на запись к различным полям регистра, как определено в SVD-файле производителя чипа.
Аналогично Вы можете найти все функции, доступные для 'w' для конкретного регистра конкретной периферии конкретного чипа в [документации по tm4c123x][tm4c123x documentation W]. Заметьте, что все поля,
которые мы не определили будут установлены в значение по умолчанию - все данные, имеющиеся в регистре
будут потеряны.

```rust,ignore
pwm.ctl.write(|w| w.globalsync0().clear_bit());
```

### Изменение

Если мы хотим изменить только одно (несколько) конкретное поле регистра, а остальные оставить неизменными,
мы можем использовать функцию `modify`. Эта функция принимает замыкание с двумя аргументами -
один для чтения и один для записи. Обычно мы называем их `r` и `w` соответственно.
Аргумент `r` можно использовать, чтобы проверить текущее содержимое регистра, а `w` - чтобы изменить
его содержимое.

```rust,ignore
pwm.ctl.modify(|r, w| w.globalsync0().clear_bit());
```

Функция `modify` показывает настоящую силу замыканий. В C нам нужно было бы прочитать содержимое регистра
в какую-то временную переменную, изменить биты, а затем записать значение обратно.
А это большой простор для ошибок:

```C
uint32_t temp = pwm0.ctl.read();
temp |= PWM0_CTL_GLOBALSYNC0;
pwm0.ctl.write(temp);
uint32_t temp2 = pwm0.enable.read();
temp2 |= PWM0_ENABLE_PWM4EN;
pwm0.enable.write(temp); // Ох! Неправильная переменная!
```

[svd2rust]: https://crates.io/crates/svd2rust
[tm4c123x documentation R]: https://docs.rs/tm4c123x/0.7.0/tm4c123x/pwm0/ctl/struct.R.html
[tm4c123x documentation W]: https://docs.rs/tm4c123x/0.7.0/tm4c123x/pwm0/ctl/struct.W.html

## Использование HAL-крейта

Крейт чипа типа HAL обычно работает реализуя обычный Типаж для сырых структур, доступных из PAC.
Часто этот типаж будет определять функцию под названием `constrain()` для целого периферийного устройства
или `split()` для таких вещей как порты ввода/вывода с множеством пинов. Эта функция буде поглощать
базовую сырую структуру периферийного устройства и возвращать новый объект, обладающий высокоуровневым API.
В этом API может, например, у порта Serial быть функция `new`, требующая заимствование структуры `Clock`,
которая может быть сгенерирована вызовом функции, которая конфигурирует PLL'ы и настраивает все тактовые частоты.
Таким образом, невозможно статически создать объект порта Serial раньше, чем будут сконфигурированы
тактовые частоты, или для объекта порта Serial неправильно сконвертировать скорость в бодах в такты
системных часов. Некоторые крейты определяют специальные типажи для всех состояний, в которых может быть
каждый пин GPIO, требуя, чтобы пользователь установил пин в корректное состояние (скажем, выбрав
соответствующий режим альтернативной функции), прежде чем передавать пин объектам периферии.
И все это бесплатно в рантайме!

Давайте убедимся на примере:

```rust,ignore
#![no_std]
#![no_main]

extern crate panic_halt; // обработчик паники

use cortex_m_rt::entry;
use tm4c123x_hal as hal;
use tm4c123x_hal::prelude::*;
use tm4c123x_hal::serial::{NewlineMode, Serial};
use tm4c123x_hal::sysctl;

#[entry]
fn main() -> ! {
    let p = hal::Peripherals::take().unwrap();
    let cp = hal::CorePeripherals::take().unwrap();

    // Заворачиваем структуру SYSCTL в объект с высокоуровневым API
    let mut sc = p.SYSCTL.constrain();
    // Указываем настройки тактирования
    sc.clock_setup.oscillator = sysctl::Oscillator::Main(
        sysctl::CrystalFrequency::_16mhz,
        sysctl::SystemClock::UsePll(sysctl::PllOutputFrequency::_80_00mhz),
    );
    // Конфигурируем PLL в соответствии с настройками
    let clocks = sc.clock_setup.freeze();

    // Заворачиваем структуру GPIO_PORTA в объект с высокоуровневым API
    // Заметьте, ей нужно заимствовать `sc.power_control`, потому что она
    // автоматически запитывает периферию GPIO.
    let mut porta = p.GPIO_PORTA.split(&sc.power_control);

    // Активировать UART.
    let uart = Serial::uart0(
        p.UART0,
        // Пин передачи (TX)
        porta
            .pa1
            .into_af_push_pull::<hal::gpio::AF1>(&mut porta.control),
        // Пин приема (RX)
        porta
            .pa0
            .into_af_push_pull::<hal::gpio::AF1>(&mut porta.control),
        // No RTS or CTS required
        (),
        (),
        // Скорость передачи
        115200_u32.bps(),
        // Тип обработчика данных
        NewlineMode::SwapLFtoCRLF,
        // Нам нужно это, чтобы настройть делители скорости передачи в соответствии с частотой
        &clocks,
        // Нам нужно это, чтобы запитатть периферию UART
        &sc.power_control,
    );

    loop {
        writeln!(uart, "Hello, World!\r\n").unwrap();
    }
}
```
