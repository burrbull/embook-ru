# Периферия как конечный автомат

Периферию микроконтроллера можно представить как набор конечных автоматов (state machines).
Например, настройку [пина GPIO][GPIO pin] можно упрощенно представить тремя состояниями:

[GPIO pin]: https://en.wikipedia.org/wiki/General-purpose_input/output

* Отключен
* Включен
    * Настроен как Выход
        * Выход: Высокий
        * Выход: Низкий
    * Настроен как Вход
        * Вход: с высоким сопротивлением
        * Вход: подтянут к земле
        * Вход: подтянут к питанию

Если периферия стартует из режима `Отключен`, чтобы перевести её в режим `Вход: с высоким сопротивлением`,
мы должны пройти следующие шаги:

1. Отключен
2. Включен
3. Настроен как Вход
4. Вход: с высоким сопротивлением

Если мы хотим перейти из `Вход: с высоким сопротивлением` в `Вход: подтянут к земле`, нужно пройти шаги:

1. Вход: с высоким сопротивлением
2. Вход: подтянут к земле

Соответственно, если мы хотим чтобы пин GPIO перешел из режима `Вход: подтянут к земле` в `Выход: Высокий`,
нам нужно пройти шаги:

1. Вход: подтянут к земле
2. Настроен как Вход
3. Настроен как Выход
4. Выход: Высокий

## Аппаратное Представление

Обычно состояния, приведенные выше устанавливаются записью значений в регистры периферии GPIO.
Давайте определим воображаемый регистр настройки GPIO, чтобы проиллюстрировать это:

| Название     | Номер бита | Значение | Состояние | Примечания |
| ---:         | ------------: | ----: | ------:   | ----: |
| enable       | 0             | 0     | disabled  | Отключает GPIO |
|              |               | 1     | enabled   | Включает GPIO |
| direction    | 1             | 0     | input     | Настраивает на Вход |
|              |               | 1     | output    | Настраивает на Выход |
| input_mode   | 2..3          | 00    | hi-z      | Вход с высоким сопротивлением |
|              |               | 01    | pull-low  | Вход подтянут к земле |
|              |               | 10    | pull-high | Вход подтянут к питанию |
|              |               | 11    | n/a       | Неверное сотояние. Не установливать |
| output_mode  | 4             | 0     | set-low   | Низкое напряжение на Выходе |
|              |               | 1     | set-high  | Высокое напряжение на Выходе |
| input_status | 5             | x     | in-val    | 0 если Вход < 1.5В, 1 если >= 1.5В |

Мы _могли бы_ создать следующую структуру Rust для управления этим GPIO:

```rust,ignore
/// Интерфейс GPIO
struct GpioConfig {
    /// Структура конфигурации GPIO, сгенерированная svd2rust
    periph: GPIO_CONFIG,
}

impl Gpio {
    pub fn set_enable(&mut self, is_enabled: bool) {
        self.periph.modify(|_r, w| {
            w.enable().set_bit(is_enabled)
        });
    }

    pub fn set_direction(&mut self, is_output: bool) {
        self.periph.modify(|r, w| {
            w.direction().set_bit(is_output)
        });
    }

    pub fn set_input_mode(&mut self, variant: InputMode) {
        self.periph.modify(|_r, w| {
            w.input_mode().variant(variant)
        });
    }

    pub fn set_output_mode(&mut self, is_high: bool) {
        self.periph.modify(|_r, w| {
            w.output_mode.set_bit(is_high)
        });
    }

    pub fn get_input_status(&self) -> bool {
        self.periph.read().input_status().bit_is_set()
    }
}
```

Однако, это бы позволило нам устанавливать регистры в состояния, не имеющие смысла.
Например, что случится, если установить поле `output_mode`, когда GPIO настроен на Вход?

В большинстве случаев, использование этой структуры позволит нам переходить в состояния, не определенные
конечным автоматом выше: например выход, подтянутый к земле, или вход, установленный в высокое состояние.
Для какого-то оборудования это не имеет значения. Для другого может вызвать неожиданное и неопределенное поведение!

Хотя такой интерфейс и удобен для записи, он не он не соответствует критериям проектирования, установленным аппаратной реализацией.
