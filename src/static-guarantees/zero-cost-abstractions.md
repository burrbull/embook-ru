# Абстракции нулевой стоимости

Типы-состояния также являются прекрасным примером Абстракций нулевой стоимости - возможности переносить
определенное поведение на этап анализа и выполнения компиляции. Такие типы не содержат реальных данных
и вместо этого используются как маркер. Так как они не содержат данных, то и в памяти рантайма ничем не
представлены:

```rust,ignore
use core::mem::size_of;

let _ = size_of::<Enabled>();    // == 0
let _ = size_of::<Input>();      // == 0
let _ = size_of::<PulledHigh>(); // == 0
let _ = size_of::<GpioConfig<Enabled, Input, PulledHigh>>(); // == 0
```

## Типы нулевого размера

```rust,ignore
struct Enabled;
```

Структуры, определяемые подобно этой называются Типами нулевого размера, так как не содержат реальных данных.
Тем не менее на этапе компиляции они работают как "настоящие" - Вы можете их копировать, перемещать,
брать ссылки на них, и т.п., но оптимизатор их вырежет.

Вот кусочек кода:

```rust,ignore
pub fn into_input_high_z(self) -> GpioConfig<Enabled, Input, HighZ> {
    self.periph.modify(|_r, w| w.input_mode().high_z());
    GpioConfig {
        periph: self.periph,
        enabled: Enabled,
        direction: Input,
        mode: HighZ,
    }
}
```

Структуры GpioConfig, которую мы возвращает в рантайме нет. Вызов этой функции, как правило, сводится к одной
ассемблерной инструкции - записи константы в регистр. Это означает, что разработанный нами интерфейс
состояния типа является абстракцией с нулевой стоимостью - он не использует ЦПУ, ОЗУ или пространство кода
для отслеживания состояние `GpioConfig`, и генерирует тот же машинный код, что и прямой доступ к регистру.

## Вложенность

Вообще такие абстракции могут иметь любую вложенность. Пока все компоненты - типы нулевого размера,
вся структура не существует во время выполнения.

Для сложных и глубоковложенных структур, может быть утомительно определять все возможные комбинации состояний. В этих случаях для генерации всех реализаций можно использовать макросы.
