# Окружение `no_std` в Rust

Термин Embedded программирование охватывает широкий класс в программировании.
Начиная от программирования 8-битный MCU (таких как [ST72325xx](https://www.st.com/resource/en/datasheet/st72325j6.pdf)) с как минимум несколькими KB ОЗУ или ПЗУ, до таких систем как Raspberry Pi
([Model B 3+](https://en.wikipedia.org/wiki/Raspberry_Pi#Specifications)), у которых 32/64-битные
4-ядерные Cortex-A53 @ 1.4 GHz и 1GB ОЗУ. Различные ограничения, программные и аппаратные, будут
возникать в процессе написания кода в зависимости от того какую цель Вы ставите и какой у Вас
сценарий использования.

Есть два основных класса Embedded программирования:

## Hosted Environments
Это типы окружений, близкие к обычной среде PC.
Это значит, что Вам предоставляется Системный интерфейс [Например POSIX](https://en.wikipedia.org/wiki/POSIX),
который имеет в наличии примитивы для взаимодействия с разнообразными системами, такими как
файловые системы, сеть, управление памятью, потоки и др.
Стандартные библиотеки в свою очередь полагаются на эти примитивы при реализации своей фунциональности.
У Вас могут также быть различные sysroot и ограничения по использованию ОЗУ/ПЗУ, и возможно
какое-то спецоборудование или Ввод/Вывод. Все это дает ощущение программирования в PC-среде специального
назначения.

## Окружение Bare Metal
На "голом железе" перед запуском Вашей программы не будет загружаться никакого кода.
И без приложений, предоставляемых ОС нельзя загрузить стандартную библиотеку [libstd](https://doc.rust-lang.org/std/).
Вместо этого программа сможет использовать только определенные крейты и запускаться только
на устройстве (голое железо).
Чтобы отключить загрузку стандартной библиотеки rust, используйте `no_std`.
Платформо-независимые части стандартной библиотеки доступны через [libcore](https://doc.rust-lang.org/core/).
Из libcore также исключены вещи, которые не всегда уместны в embedded среде.
Одна из таких вещей - аллокатор памяти для динамического распределения памяти.
Если Вам нужна его функциональность, чаще всего есть крейт ее реализующий.


### libstd рантайм
Как говорилось раннее, использование [libstd](https://doc.rust-lang.org/std/) требует определенной
системной интеграции, но это не только потому, что в [libstd](https://doc.rust-lang.org/std/)
предоставляется общий способ доступа к абстракциям ОС, а также из-за того, что она предоставляет рантайм.
Этот рантайм, среди прочего, заботится о защите стека от переполнения, обрабатывает аргументы
командной строки и порождает основной поток программы до того, как буде запущена функция main.
Этот рантайм также не может быть доступен в окружении `no_std`.

## Итоги
`#![no_std]` - атрибут крейт-уровня, который показывает, что крейт будет линковаться с core-крейтами вместо std-крейтов.
Крейт [libcore](https://doc.rust-lang.org/core/) в свою очередь - платформо независимое подмножество крейта std,
который не делает никаких предположений о системе, на которой программа будет запускаться.
As such, он предоставляет API для языковых примитивов, таких как вещественные числа, строки и срезы, а также as API, которые экспонируют процессорные возможности, такие как атомарные операции и SIMD-инструкции. Однако из него убраны API для всего, что включает интеграцию с платформой.
Из-за этих свойств no\_std и [libcore](https://doc.rust-lang.org/core/) код можно использовать для любого вида
загрузочного (состояние 0) кода, такого как загрузчики, прошивки и ядра.

### Overview

| функционал                                                | no\_std | std |
|-----------------------------------------------------------|--------|-----|
| куча (динамическая память)                                |   *    |  ✓  |
| коллекции (Vec, HashMap, и т.п.)                          |  **    |  ✓  |
| защита от переполнения стека                              |   ✘    |  ✓  |
| запуск кода инциализации перед main                       |   ✘    |  ✓  |
| доступность libstd                                        |   ✘    |  ✓  |
| доступность libcore                                       |   ✓    |  ✓  |
| программирование прошивки, ядра или загрузочного кода     |   ✓    |  ✘  |

\* Только если Вы используете крейт `alloc` и подходящий аллокаторк типа [alloc-cortex-m].

\** Только если используете крейт `collections` и настроили глобальный аллокатор по умолчанию.

[alloc-cortex-m]: https://github.com/rust-embedded/alloc-cortex-m

## Смотрите также
* [RFC-1184](https://github.com/rust-lang/rfcs/blob/master/text/1184-stabilize-no_std.md)
