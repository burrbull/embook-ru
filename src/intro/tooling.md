# Инструменты

Работа с микроконтроллерами включает использование ряда инструментов так, как если бы
мы работали с архитектурой, отличной от той, что у Вас на ноутбуке, но должны были
запускать и отлаживать программы на *удаленном* устройстве.

Мы будем использовать все интструменты, перечисленные ниже. Любая свежая
версия должна работать, если минимальная версия не указана, но мы перечислили
версии, которые были нами протестированы.

- Rust 1.31, 1.31-beta, или более новый тулчейн ПЛЮС поддержка компиляции ARM Cortex-M.
- [`cargo-binutils`](https://github.com/rust-embedded/cargo-binutils) ~0.1.4
- [`qemu-system-arm`](https://www.qemu.org/). Tested versions: 3.0.0
- OpenOCD >=0.8. Протестированы версии: v0.9.0 и v0.10.0
- GDB с поддержкой ARM. Версия 7.12 или новее настоятельно рекомендуется.
  Протестированы версии: 7.10, 7.11, 7.12 и 8.1
  [`cargo-generate`](https://github.com/ashleygwilliams/cargo-generate) или `git`.
  Эти инструменты опциональны, но Вам будет проще работать с книгой.

Ниже поясняется почему мы используем эти инструменты. Инструкции по установке
можно найти на следующей странице.

## `cargo-generate` ИЛИ `git`

Bare metal программы не являются стандартными (`no_std`) программами на Rust, они
требуют некоторой корректировки процесса линковки с целью получить правильное
отображение программы в памяти. Это требует некоторых дополнительных файлов
(таких как линковочный скрипт) и настроек (как флаги линковки). Мы упаковали их
для вас в шаблон, в котором нужно заполнить только недостающую информацию
(такую как имя проекта и характеристики целевого оборудования).

Наш шаблон совместим с `cargo-generate`: подпрограммой Cargo для создания
новых проектов Cargo из шаблонов. Вы также можете загрузить шаблон с
помощью `git`, `curl`, `wget` или Вашим веб-браузером.

## `cargo-binutils`

`cargo-binutils` - коллекция подпрограмм Cargo, упрощающая использование инструментов
LLVM, которые поставляются с тулчейном Rust. Эти инструменты включают
LLVM-версии `objdump`, `nm` и `size` и используются для изучения бинарных файлов.

Преимущество использования этих инструментов перед GNU binutils в том, что (a) устанавливаются
LLVM-инструменты одной и той же командой (`rustup component add llvm-tools-preview`)
независимо от Вашей ОС и (b) инструменты вроде `objdump` поддерживают
все архитектуры, которые поддерживает `rustc` -- от ARM до x86_64 -- потому что оба
поставляются одним LLVM-бэкендом.

## `qemu-system-arm`

QEMU - это эмулятор. В нашем случае используется вариант, который может полностью
эмулировать системы ARM. Мы используем QEMU для запуска embedded программ на хост.
Благодаря этому Вы можете пройти часть этой книги даже если у Вас нет никакого
оборудования!

## GDB

Отладчик - очень важный компонент разработки встраиваемых устройств, т.к. не
всегда может быть такая роскошь, как передавать данные в консоль хоста. В некоторых случаях у
Вас может не быть даже светодиодов, чтобы ими помигать на Вашем оборудовании!

Обычно LLDB работает также хорошо как и GDB когда дело касается отладки, но мы не
смогли найти LLDB аналог команды `load` из GDB, которая загружает программу в целевое
оборудование, поэтому пока мы рекомендуем использовать GDB.

## OpenOCD

GDB не умеет напрямую общаться непосредственно с программатором ST-Link на Вашей
отладочной плате STM32F3DISCOVERY. Ему нужен переводчик и Open
On-Chip Debugger, OpenOCD - этот переводчик. OpenOCD - программа, которая запускается
на Вашем ноутбуке/ПК и осуществляет перевод между основанным на TCP/IP протоколом
удаленной отладки GDB и основанным на USB протоколе ST-Link.

OpenOCD также выполняет важную работу как часть этого перевода для отладки
основанном на ARM Cortex-M микроконтроллере на Вашей отладочной плате STM32F3DISCOVERY:
* Он знает как взаимодействовать с memory mapped регистрами, используемыми ARM
  CoreSight периферией отладки. Вот эти CoreSight регистры, которые предусматривают:
  * Манипуляции точками останова/наблюдения
  * Чтение и запись регистров ЦПУ
  * Определение, когда ЦПУ останавливается на отладочном событии
  * Продолжение работы ЦПУ после обнаружения отладочного события
  * и др.
* Он также знает как очищать и записывать FLASH микроконтроллера
