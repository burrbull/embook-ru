# Коллекции

В какой-то момент вам захочется использовать динамические структуры данный (читай коллекции)
в своей программе. `std` предоставляет набор наиболее часто используемых коллекции: [`Vec`], [`String`],
[`HashMap`], и др. Все коллекции, реализованные в `std`, используют глобальный
аллокатор динамической памяти (читай кучю).

[`Vec`]: https://doc.rust-lang.org/std/vec/struct.Vec.html
[`String`]: https://doc.rust-lang.org/std/string/struct.String.html
[`HashMap`]: https://doc.rust-lang.org/std/collections/struct.HashMap.html

Так каа `core` по определению избавлен от аллокаций памяти, там этих реализаций
нет, но их можно найти в крейте `alloc`, поставляемом с компилятором.

Если Вам нужны коллекции, реализации, основанные на аллокации в куче, не единственный вариант.
Вы можете использовать коллекции *фиксированной ёмкости*; одну из реализаций можно найти
в крейте [`heapless`].

[`heapless`]: https://crates.io/crates/heapless

В этом разделе, мы исследуем и сравним эти две реализации.

## Использование `alloc`'а

Крейт `alloc` - часть дистрибутива Rust. Чтобы импортировать крейт, нужно
просто использовать (`use`) его *не* определяя его как зависимость в файле `Cargo.toml`.

``` rust,ignore
#![feature(alloc)]

extern crate alloc;

use alloc::vec::Vec;
```

Но чтобы использовать любую из коллекций, сначала нужно использовать атрибут `global_allocator`,
чтобы определить глобальный аллокатор, который будет использовать ваша программа.
Необходимо, чтобы аллокатор, который Вы выбрали реализовывал трейт [`GlobalAlloc`].

[`GlobalAlloc`]: https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html

Для полноты, и чтобы сделать этот раздел самодостаточным, мы реализуем простой bump pointer
аллокатор, и используем его как глобальный.
Однако, мы *настоятельно* использовать проверенный в бою аллокатор из crates.io
в вашей программе вместо этого аллокатора.

``` rust,ignore
// Реализация bump pointer аллокатора

extern crate cortex_m;

use core::alloc::GlobalAlloc;
use core::ptr;

use cortex_m::interrupt;

// Bump pointer аллокатор *одноядерных* систем
struct BumpPointerAlloc {
    head: UnsafeCell<usize>,
    end: usize,
}

unsafe impl Sync for BumpPointerAlloc {}

unsafe impl GlobalAlloc for BumpPointerAlloc {
    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
        // `interrupt::free` - критическая секция, делающая наш аллокатор
        // безопасным при работе с прерываниями
        interrupt::free(|_| {
            let head = self.head.get();

            let align = layout.align();
            let res = *head % align;
            let start = if res == 0 { *head } else { *head + align - res };
            if start + align > self.end {
                // нулевой указатель обозначает состояние выхода за границу памяти
                ptr::null_mut()
            } else {
                *head = start + align;
                start as *mut u8
            }
        })
    }

    unsafe fn dealloc(&self, _: *mut u8, _: Layout) {
        // аллокатор никогда не деаллоцирует память
    }
}

// Определение глобального аллокатора памяти
// ПРИМЕЧАНИЕ: пользователь должен убедиться, что регион памяти `[0x2000_0100, 0x2000_0200]`
// не используется другими частями программы
#[global_allocator]
static HEAP: BumpPointerAlloc = BumpPointerAlloc {
    head: UnsafeCell::new(0x2000_0100),
    end: 0x2000_0200,
};
```

Помимо выьора глобального аллокатора пользователь также должен будет определить как
будут обрабатываться ошибки выхода за границу памяти Out Of Memory (OOM) используя
*нестабильный* атрибут `alloc_error_handler`.

``` rust,ignore
#![feature(alloc_error_handler)]

use cortex_m::asm;

#[alloc_error_handler]
fn on_oom(_layout: Layout) -> ! {
    asm::bkpt();

    loop {}
}
```

Как только все на месте, пользователь может наконец использовать колекции из `alloc`.

```rust,ignore
#[entry]
fn main() -> ! {
    let mut xs = Vec::new();

    xs.push(42);
    assert!(xs.pop(), Some(42));

    loop {
        // ..
    }
}
```

Если Вы уже использовали коллекции из крейта `std`, то уже знакомы с ними.

## Использование `heapless`

`heapless` не требует установки, так как эти коллекции не зависят от глобального
аллокатора памяти. Просто используйте (`use`) их:

```rust,ignore
extern crate heapless; // v0.4.x

use heapless::Vec;
use heapless::consts::*;

#[entry]
fn main() -> ! {
    let mut xs: Vec<_, U8> = Vec::new();

    xs.push(42).unwrap();
    assert_eq!(xs.pop(), Some(42));
}
```

Вы видите два отличия между этими коллекциями и теми, что в `alloc`.

Во-первых, Вам нужно определить ёмкость коллекции заранее. `heapless` коллекции
никогда не меняют положения в памяти и имеют фиксированную ёмкость; ёмкость - это часть
сигнатуры коллекции. В нашем случае мы определили, что `xs` имеет ёмкость размером 8 элементов,
поэтому вектор может разместить не более 8 элементов.
Это отражено типом `U8` (см. [`typenum`]) в сигнатуре типа.

[`typenum`]: https://crates.io/crates/typenum

Во-вторых, метод `push`, и многие другие, возвращает `Result`. Так как
`heapless` коллекции имеют фиксированную ёмкость, все операции по вставке элементов в вектор
потенциально могут завершиться с ошибкой. Эта проблема отражается на API возвращаемым типом
`Result`, показывающим, завершилась операция успешно или нет.
Для сравнения, коллекции из `alloc` будут переаллоцировать себя в куче, чтобы увеличить свою ёмкость.

Начиная с версии v0.4.x все `heapless` коллекции размещают все свои элементы внутри.
Это значит, что такие операции, как `let x = heapless::Vec::new();` будут аллоцировать
коллекции на стеке, но также возможно аллоцировать коллекцию в статической (`static`) переменной,
или даже в куче (`Box<Vec<_, _>>`).

## Компромиссы

Помните об этом, когда будете выбирать между аллоцируемыми в куче, реаллоцируемыми коллекциями
и коллекциями фиксированной ёмкости.

### Out Of Memory или обработка ошибок

С аллокациями в куче всегда возможен выход за границу памяти, которая может произойти
в любой момент, когда коллекции нужно увеличить размер: например, все вызовы
`alloc::Vec.push` потенциально могут создать состояние OOM. Поэтому
некоторые операции могут *неявно* не выполняться. Некоторык коллекции `alloc` предоставляют
методы `try_reserve`, котрые позволяют проверить возможность состояния OOM при росте коллекции,
но Вы должны сами подумать об их использовании.

Если Вы используете исключительно `heapless` коллекции и не используете аллокатор памяти
для чего-либо ещё, тогда состояние OOM невозможно. Вместо этого Вы будете иметь дело с
с выходом за границу ёмкости коллекции в каком-нибудь случае.
И поэтому Вам нужно обрабатывать *все* `Result`ы, возвращаемые методами подобними `Vec.push`.

Ошибки OOM могут быть сложнее в отладке, чем, скажем разворачиваyние (`unwrap`) всех `Result`ов,
возвращаемых `heapless::Vec.push`, потому что наблюдаемое положение ошибки может
*не* совпадать с положением в программе, вызвавшим проблему. Например, даже
`vec.reserve(1)` может привести к OOM, если аллоцирована почти вся память, потому что
у некоторых других коллекций утекла память (утечки памяти возможны в безопасном Rust).

### Использование памяти

Рассуждать об использовании памяти выделенных в куче коллекций сложно, поскольку
емкость долгоживущих коллекций может изменяться во время выполнения. Некоторые операции
могут неявно переаллоцировать коллекцию, увеличивая используемою ей память, а некоторые
коллекции предоставляют методы, такие как `shrink_to_fit`, которые могут потенциально
уменьшить используемую коллекцией память -- в конечном счете аллокатор для того и предназначен,
чтобы решать, нужно уменьшать используемую память или нет. К тому же аллокатору придется иметь дело с фрагментацией памяти, которая может увеличивать *кажущееся* использование памяти.

С другой стороны, если Вы используете исключитьельно коллекции фиксированной ёмкости,
размещаете их в основном в статических переменных и установили максимальный размер для
стека вызовов, линковщик определит если Вы пытаетесь использовать памяти болше, чем
физически доступно.

Более того, коллекции фиксированной ёмкости аллоцированные на стеке будут помечены флагом
[`-Z emit-stack-sizes`], который обозначает, что инструменты, которые анализируют использование стека,
(такие как [`stack-sizes`]), включат их в свой анализ.

[`-Z emit-stack-sizes`]: https://doc.rust-lang.org/beta/unstable-book/compiler-flags/emit-stack-sizes.html
[`stack-sizes`]: https://crates.io/crates/stack-sizes

Однако, коллекции фиксированной ёмкости *не* могут сжиматься, что выливается в низкий
фактор заполняемости (отношение между размером коллекции и её ёмкостью) по сравнению с
коллекциями, аллоцируемыми в куче.

### Наихудшее время выполнения (WCET)

Если вы создаете приложения, чувствительные ко времени или приложения жесткого реального времени,
то беспокоитесь, возможно сильно, о наихудшем времени выполнения различных участков программы.

Коллекции из `alloc` могут переаллоцироваться, поэтому WCET операции, которая может
увеличивать коллекцию, также будет включать время на её переаллокацию, которое
само по себе зависит от *текущей* ёмкости коллекции во время работы. Это делает
сложным определение WCET, например, операция `alloc::Vec.push`, так как она зависит как от
используемого аллокатора, так и текущей ёмкости.

С другой стороны коллекции фиксированной ёмкости никогда не переаллоцируются, поэтому все
операции имеют предсказуемое время выполнения. Например, `heapless::Vec.push` выполняется
фиксированное время.

### Легкость использования

`alloc` требует установку глобального аллокатора, в то время как `heapless` - нет.
Однако, `heapless` требует, чтобы Вы определялись с ёмкостью каждой коллекции, которую
собираетесь создать.

API `alloc`'а будет знакомо практически каждому Rust разработчику. API `heapless`
пытается быть максимально похожим на API `alloc`, но никогда не будет идентичным
из-за явной обработки ошибок -- некоторым разработчикам явная обработка ошибок
может показаться чрезмерной или слишком громоздкой.
