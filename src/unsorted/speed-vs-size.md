# Оптимизации: компромисс скорости и размера

Каждый хочет, чтобы его программа была супербыстрой и крохотной, но обычно
невозможно иметь обе характеристики. В этом разделе обсуждаются различные
уровни оптимизации, которые предоставляются компилятором `rustc`, и как они
влияют на размер исполняемого файла программы.

## Без оптимизаций

Так по умолчанию. Когда Вы вызываете `cargo build`, то используете профиль разработчика (`dev`).
Этот профиль оптимизирован для отладки, поэтому включает отладочную информацию
и *не* включает никаких оптимизаций, т.е. использует `-C opt-level = 0`.

По крайней мере для разработчиков на "голом металле", отладочная информация имеет
нулевую стоимость в том смысле, что не занимает местов Flash / ПЗУ, поэтому мы
настоятельно рекомендуем включать отладочную информацию в release профиле --
по умолчанию она отключена. Это позволит вам использовать точки останова
при отладке release сборки.

``` toml
[profile.release]
# символы это хорошо, и они не увеличивают размер во Flash
debug = true
```

Отсутствие оптимизаций - это хорошо для отладки, поскольку пошаговое выполнения кода выглядит
как переход программы из состояния в состояние, плюс Вы можете печатать (`print`)
переменные на стеке и аргументы функций в GDB. Когда код оптимизирован,
попытка напечатать переменные приведет к печати `$0 = <value optimized out>`.

Самый главный недостаток профиля `dev` - то, что результирующий исполняемый файл будет
огромный и медленный. Размер обычно наибольшая из проблем, потому что неоптимизированные
бинарники могут занимать десятки KiB Flash, которые ваше целевое устройство может
не иметь -- результат: ваша неоптимизированная прошивка не влезет в ваше усстройство!

Можем ли мы уменьшить дружественные к отладке бинарники? Да, есть трюк.

### Оптимизация зависимостей

В Rust 1.37, есть опция Cargo, называемая [`profile-overrides`], которая позволяет
Вам переопределить уровень оптимизации зависимостей. Вы можете использовать эту опцию
для оптимизации всех зависимостей по размеру, при этом сохраняя крейт верхнего уровня
неоптимизированным и дружественным к отладке.

[`profile-overrides`]: https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#profile-overrides

Вот пример:

``` toml
# Cargo.toml
cargo-features = ["profile-overrides"] # +

[package]
name = "app"
# ..

[profile.dev.overrides."*"] # +
opt-level = "z" # +
```

Без переопределения:

``` console
$ cargo size --bin app -- -A
app  :
section               size        addr
.vector_table         1024   0x8000000
.text                 9060   0x8000400
.rodata               1708   0x8002780
.data                    0  0x20000000
.bss                     4  0x20000000
```

С переопределением:

``` console
$ cargo size --bin app -- -A
app  :
section               size        addr
.vector_table         1024   0x8000000
.text                 3490   0x8000400
.rodata               1100   0x80011c0
.data                    0  0x20000000
.bss                     4  0x20000000
```

Это 6 KiB уменьшение использования Flash без каких-либо потерь в возможностях отладки
крейта верхнего уровня. Если Вы шагнете в код зависимости, то будете видеть
`<value optimized out>` сообщения опять, но обычно вам требуется отлаживать Ваш код,
а не код зависимостей. А если вам *нужно* отладить зависимость, тогда Вы можете
применить опцию `profile-overrides`, чтобы отключить в части зависимостей оптимизацию.
Посмотрите пример ниже:

``` toml
# ..

# не оптимизировать крейт `cortex-m-rt`
[profile.dev.overrides.cortex-m-rt] # +
opt-level = 0 # +

# но оптимизировать все остальные зависимости
[profile.dev.overrides."*"]
codegen-units = 1 # улучшает оптимизацию
opt-level = "z"
```

Теперь крейты верхнего уровня и `cortex-m-rt` удобно отлаживать!

## Оптимизация по скорости

`rustc` поддерживает три уровня "оптимизации по скорости": `opt-level
= 1`, `2` и `3`. Когда Вы запускаете `cargo build --release`, то используете профиль release,
у которого по умолчанию `opt-level = 3`.

Оба `opt-level = 2` и `3` оптимизируют по скорости в ущерб размеру бинарника,
но уровень `3` делает больше векторизаций и инлайнинга, чем уровень `2`.
В частности, Вы увидете, что для `opt-level` больше или равному `2` LLVM будет
разматывать циклы. Такая операция, хотя и потребляет больше Flash / ПЗУ
(например, из 26 байт до 194 for a zero this array loop) но может вдвое уменьшить
время выполнения в подходящих условиях (например при достаточно большом числе итераций).

В настоящий момент нет способа отключить размотку циклов в для `opt-level = 2` и `3`, поэтому
если Вы не можете позволить себе её цену, Вам нужно оптимизировать программу по размеру.

## Оптимизация по размеру

`rustc` поддерживает два уровня "оптимизации по размеру": `opt-level =
"s"` и `"z"`. Эти имена пришли из clang / LLVM и не очень наглядны, но смысл `"z"`
в том, что он делает бинарники меньше, чем `"s"`.

Если Вы хотите, чтобы Ваша release прошивка была оптимизирована по размеру,
измените `profile.release.opt-level`, установив его в `Cargo.toml` как показано ниже.

``` toml
[profile.release]
# или "z"
opt-level = "s"
```

Эти два уровня оптимизации значительно уменьшают внутренние уставки LLVM,
метрики, используемые для выбора инлайнить функцию или нет. Один из принципов Rust -
абстракции нулевой стоимости; эти абстракции, как правило, используют много новых типов
и небольших функций для хранения инвариантов (например, функций, которые заимствуют
внутреннее значение, такие как `deref`,` as_ref`), поэтому низкие внутренние уставки
могут заставить LLVM игнорировать возможные оптимизации (например устранять
мертвые ветки, инлайнить вызовы замыканий).

Когда оптимизируете по размеру, Вы можете захотеть попытаться увеличить внутреннюю уставку,
чтобы увидеть, влияет ли она как-нибудь на размер. Рекомендуемый способ изменить уставку -
добавить флаг `-C inline-threshold` к другим флагам в `.cargo/config`.

``` toml
# .cargo/config
# предполагается, что Вы используете шаблон cortex-m-quickstart
[target.'cfg(all(target_arch = "arm", target_os = "none"))']
rustflags = [
  # ..
  "-C", "inline-threshold=123", # +
]
```

Какое значение использовать? [Начиная с 1.29.0 есть такие уставки, которые
используют разные уровни оптимизации][inline-threshold]:

[inline-threshold]: https://github.com/rust-lang/rust/blob/1.29.0/src/librustc_codegen_llvm/back/write.rs#L2105-L2122

- `opt-level = 3` использует 275
- `opt-level = 2` использует 225
- `opt-level = "s"` использует 75
- `opt-level = "z"` использует 25

Можете попробовать `225` и `275`, когда оптимизируете по размеру.
