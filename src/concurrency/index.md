# Конкурентность

Конкурентность возникает когда разные части вашей программы запускаются в разное
время или в разном порядке. В эмбеддед контексте она включает:

* обработчики прерываний, которые запускаются в любой момент, когда происходит прерывание,
* различные формы многопоточности, когда ваш микропроцессор регулярно переключается
  между частями программы,
* и в некоторых системах с многоядерными микропроцессорами, когда каждое ядро может
  независимо запускаю разные части ваше программы одновременно.

Так как многие программы для встраиваемых систем должны работать с прерываниями, конкурентность
рано или позно возникнет, и здесь могут появиться множество трудноуловимых ошибок.
К счастью, Rust предоставляет ряд абстракций и гарантий безопасности, чтобы помочь
нам писать корректный код.

## Когда нет конкуренции

Простейшая форма конкурентности в эмбеддед программах - это когда нет конкуренции:
ваш программный код состоит из одного главного цикла, который просто продолжает выполняться,
и прерывания отсутствуют вовсе. Иногда это идеально подходит для решения проблемы!
Обычно  таких случаях ваш цикл будет читать некоторые входные данные,
выполнять некоторую обработку и записывать некоторые выходные данные.

```rust,ignore
#[entry]
fn main() {
    let peripherals = setup_peripherals();
    loop {
        let inputs = read_inputs(&peripherals);
        let outputs = process(inputs);
        write_outputs(&peripherals, outputs);
    }
}
```

Так как конкуренции нет, то нет нужды беспокоиться о распределении данных
между частями вашей программы или синхронизировать доступ к периферии.
Если вы можете обойтись таким простым подходом, это может стать отличным решением.

## Глобальные изменяемые данные

В отличие от неэмбеддед Rust'а, у нас обычно не будет такой роскоши, как аллокации данных в куче
и передача ссылок на эти данные во вновь созданный поток.
Вместо этого наши обработчики прерываний могут быть вызваны в любое время и
должны значть, как получить доступ к любой разделяемой памяти, которую мы используем.
На самом нижнем уровне это значит, что мы должны иметь
_статически аллоцированную_ изменяемую память, к которой могут обращаться
как обработчик прерывания, так и главный код программы.

В Rust, такие [`static mut`] переменные всегда небезопасны для чтения или записи,
потому что без специальных мер предосторожности, Вы можете вызвать состояние гонки данных,
когда Ваше обращение к переменной прерывается на полпути
прерыванием, которое также обращается к этой переменной.

[`static mut`]: https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#accessing-or-modifying-a-mutable-static-variable

Для примера как такое поведение может вызвать трудноуловимые ошибки в коде,
рассмотрим эмбеддед программу, которая считает передные фронты входных сигналов
в каждом односекундном периоде (счетчик частоты):

```rust,ignore
static mut COUNTER: u32 = 0;

#[entry]
fn main() -> ! {
    set_timer_1hz();
    let mut last_state = false;
    loop {
        let state = read_signal_level();
        if state && !last_state {
            // ОПАСНОСТЬ - На самом деле не безопасно! Может вызвать гонку данных.
            unsafe { COUNTER += 1 };
        }
        last_state = state;
    }
}

#[interrupt]
fn timer() {
    unsafe { COUNTER = 0; }
}
```

Каждую секунду прерывание таймера сбрасывает счетчик. В тоже время
главный цикл постоянно измеряет сигнал, и увеличивает счетчик, когда видит
сигнал перешел из низкого состояния в высокое. Нам нужно использовать `unsafe`,
чтобы получить доступ к `COUNTER`, так как он `static mut`, а это значит, что
мы обещаем компилятору, что не вызовем неопределенное поведение. Можете
ли Вы обнаружить гонку данных? Инкремент `COUNTER`'a _не_ гарантирует атомарность —
на самом деле в большинстве встраиваемых платформ, он будет разделен
на загрузку, собственно инкремент и сохранение данных.
Если прерывание произойдет после загрузки, но до сохранения, сброс в 0
будет проигнорирован по завершению прерывания — и мы насчитаем вдвое
больше модуляций за период.

## Критические секции

Так что мы можем сделать с гонками данных? Простой метод - это использовать
_критические секции_, контекст, в котором прерывания отключены. Оборачивая доступ к
`COUNTER` в `main` в критическую секцию, мы можем убедить прерывание таймера
не запускаться, пока мы не закончим операцию преращения `COUNTER`:

```rust,ignore
static mut COUNTER: u32 = 0;

#[entry]
fn main() -> ! {
    set_timer_1hz();
    let mut last_state = false;
    loop {
        let state = read_signal_level();
        if state && !last_state {
            // Новая критическая секция проверят синхронизацию доступа к COUNTER
            cortex_m::interrupt::free(|_| {
                unsafe { COUNTER += 1 };
            });
        }
        last_state = state;
    }
}

#[interrupt]
fn timer() {
    unsafe { COUNTER = 0; }
}
```

В этом примере мы используем `cortex_m::interrupt::free`, но на другие платформы
будут иметь похожие механизмы для выполнения кода в критической секции.
Они также отключают прерывания, запускают какой-то код, а затем перезапускают прерывания.

Заметьте, что нам не нужно вставлять критическую секцию внутрь прерывания таймера
по двум причинам:

  * На запись 0 в `COUNTER` не влияет гонка, так как мы его не читаем
  * Прерывание никогда не будет прервано потоком `main`

Если `COUNTER` было разделено множеством обработчиков, которые могут
_вытеснять_ друг друга, тогда каждый из них также может требовать наличие критической секции.

Это решило нашу первоочередную проблему, но мы всё ещё пишет много
`unsafe` кода, о котором нужно заботиться, и мы можем использовать критические секции
без необходимости - что обходится слишком дорого, задерживая прерывания и вызывая дребезг.

Стоит отметить, что хотя критическая секция гарантирует, что прерывания не запустится,
она не дает гарантий эксклюзивности для многоядерных систем! Другое ядро может без проблем
получить доступ к той же памяти, что и ваше ядро, даже без прерываний.
Вам понадобятся более мощные примитивы синхронизации, когда вы используете несколько ядер.

## Атомарный доступ

На некоторых платформах доступны атомарные инструкции, которые предоставляют
гарантии касательно операций чтения-изменения-записи.
Что касается Cortex-M, `thumbv6` (Cortex-M0) не предоставляет атомарных инструкций,
в то время как `thumbv7` (Cortex-M3 и выше) предоставляет. Эти инструкции дают
альтернативу тяжеловесному отключению всех прерываний: когда мы будем делать инкремент,
чаще всего он будет успешным, но если он будет прерван, то автоматически повторит всю
операцию приращения. Атомарные операции безопасны даже для многоядерных систем.

```rust,ignore
use core::sync::atomic::{AtomicUsize, Ordering};

static COUNTER: AtomicUsize = AtomicUsize::new(0);

#[entry]
fn main() -> ! {
    set_timer_1hz();
    let mut last_state = false;
    loop {
        let state = read_signal_level();
        if state && !last_state {
            // Используем `fetch_add`, чтобы атомарно добавить 1 к COUNTER
            COUNTER.fetch_add(1, Ordering::Relaxed);
        }
        last_state = state;
    }
}

#[interrupt]
fn timer() {
    // Используем `store`, чтобы записать 0 напрямую в COUNTER
    COUNTER.store(0, Ordering::Relaxed)
}
```

Теперь `COUNTER` - безопасная `static` переменная. Благодаря типу `AtomicUsize`
`COUNTER` можно безопасно изменять как из обработчика прерывания,
так и главного потока программы без отключения прерываний.
Когда это возможно — это лучшее решение, но оно может не поддерживаться Вашей платформой.

Примечание к [`Ordering`]: данный тип влият на то как, компилятор и оборудование
могут переупорядочивает инструкции, а также влияет на видимость кэша.
Предполагая, что целью является одноядерная платформа, `Relaxed` - достаточный
и наиболее эффективный выбор в этом конкретном случае.
Более строгое упорядочивание приведет к тому, что компилятор создаст барьеры памяти
вокруг атомарных операций; в зависимости от того, для чего вы используете атомные
инструкции, для вас может это может понадобиться, а может и нет!
Подробности атомарной модели сложны и лучше описаны в других местах.

Для подробностей по атомарным операциям и упорядочиванию, смотрите [nomicon].

[`Ordering`]: https://doc.rust-lang.org/core/sync/atomic/enum.Ordering.html
[nomicon]: https://doc.rust-lang.org/nomicon/atomics.html


## Абстракции, Send, и Sync

Ни одно из вышеуказанных решений не является особенно удовлетворительным.
Они требуют `unsafe` блоки, которые нужно очень внимательно проверять и неприятно выглядят.
Конечно же мы можем делать это в Rust лучше!

Мы можем абстрагировать наш счетчик в безопасный интерфейс, который можно безопасно
использовать в любом месте кода. В этом примере мы будем использовать счетчик с
критической секцией, но Вы можете сделать что-то похожее с атомарными операциями.

```rust,ignore
use core::cell::UnsafeCell;
use cortex_m::interrupt;

// Наш счетчик - просто обертка вокруг UnsafeCell<u32>, который сердце
// interior mutability в Rust. Используя interior mutability, мы можем сделать
// COUNTER `static` вместо `static mut`, но при этом всё ещё иметь возможность
// изменять значение счетчика.
struct CSCounter(UnsafeCell<u32>);

const CS_COUNTER_INIT: CSCounter = CSCounter(UnsafeCell::new(0));

impl CSCounter {
    pub fn reset(&self, _cs: &interrupt::CriticalSection) {
        // Требуя передачи CriticalSection в качестве аргумента, мы убеждаемся,
        // что будем работать внутри критической секции, и поэтому можем спокойно
        // использовать unsafe блок (требуемый для вызова UnsafeCell::get).
        unsafe { *self.0.get() = 0 };
    }

    pub fn increment(&self, _cs: &interrupt::CriticalSection) {
        unsafe { *self.0.get() += 1 };
    }
}

// Нужно для static CSCounter. Смотреть объяснение ниже.
unsafe impl Sync for CSCounter {}

// COUNTER больше не `mut`, так как использует interior mutability;
// тем не менее он таже больше не требует unsafe блоков для доступа.
static COUNTER: CSCounter = CS_COUNTER_INIT;

#[entry]
fn main() -> ! {
    set_timer_1hz();
    let mut last_state = false;
    loop {
        let state = read_signal_level();
        if state && !last_state {
            // Здесь нет unsafe!
            interrupt::free(|cs| COUNTER.increment(cs));
        }
        last_state = state;
    }
}

#[interrupt]
fn timer() {
    // Нам нужно войти здесь в критическую секцию, только чтобы получить валидный
    // символ cs, даже если знаем, что никакие другие прерывания 
    //  не могут вытеснить текущее.
    interrupt::free(|cs| COUNTER.reset(cs));

    // Мы можем использовать unsafe код, чтобы сгенерировать искусственную CriticalSection,
    // если нам это действительно требуется, чтобы избежать накладных расходов:
    // let cs = unsafe { interrupt::CriticalSection::new() };
}
```

Мы переместилт наш `unsafe` код внутрь нашей бережно спланированной абстракции,
и теперь код нашего приложения не содержит `unsafe` блоков.

Такой дизайн требует, чтобы приложение передавало символ `CriticalSection`:
эти символы безопасно создаются только с помощью `interrupt::free`, поэтому требуя
передачи такого символа, мы убеждаемся, что работаем в критической секции,
при этом на самом деле не производя замыкания. Эта гарантия предоставляется
компилятором статически: в рантайме не будет накладных расходов, связанных с `cs`.
Если у нас есть несколько счетчиков, они все могут передаваться подобно `cs`,
не требуя множества вложенных критических секций.

Это также поднимает важную тему для конкурентности в Rust: трейты
[`Send` и `Sync`][SendSync]. Суммируя описанное в книге Rust, тип Send -
это когда можно безопасно перемещать объект в другой поток, в то время как Sync - это
когда можно безопасно передавать ссылку между потоками. В контексте встраиваемых систем,
мы рассматриваем прерывания, будто они выполняются в отдельном потоке относительно кода приложения,
поэтому переменные, к которым получают доступ как прерывание так и основной код,
должны быть Sync.

[SendSync]: https://doc.rust-lang.org/nomicon/send-and-sync.html

Для большинства типов Rust, оба этих трейта автоматически выводятся компилятором.
Однако из-за того, что `CSCounter` содержит [`UnsafeCell`], он не Sync,
и поэтому мы не можем создать `static CSCounter`: `static` переменные
_должны_ быть Sync, потому что к ним можно получить доступ из множества потоков.

[`UnsafeCell`]: https://doc.rust-lang.org/core/cell/struct.UnsafeCell.html

Чтобы сказать компилятору, что мы позаботились, чтобы `CSCounter` можно было
безопасно передавать между потоками, мы реализуем трейт Sync явно.
Как и предыдущие, такое использование критических секций безопасно только
на одноядерных платформах: с несколькими ядрами вам прийдется нырнуть глубже,
чтобы обеспечить безопасность.

## Mьютексы

Мы создалы полезную абстракцию, специфичную для проблемы счетчик, но есть
много абстракций общего назначения, используемые для конкурентности.

Один из таких _примитивов синхронизации_ - это мьютекс, сокращение от
mutual exclusion (взаимное исключение).
Эти конструкции обеспечивают эксклюзивныц доступ к переменной, такой как наш счетчик.
Поток может попытаться _замкнуть_ (или _захватить_) мьютекс, и либо сообщить об успехе
сразу, или заблокироваться, ожидая когда замыкание будет захвачено, либо вернуть ошибку,
означающую, что мьютекс не может быть захвачен. Пока поток удерживает замыкание,
ему предоставлен доступ к защищаемым данным. Когда поток завершается, он _размыкает_ (или
_освобождает_) мьютекс, позволяя другому потоку его замкнуть. В Rust, мы бы
обычно реализовали размыкание, используя трейт [`Drop`], чтобы убедиться, что
мьютекс всегда освобождается, когда выходит из области видимости.

[`Drop`]: https://doc.rust-lang.org/core/ops/trait.Drop.html

Использование мьютекса с обработчиками прерываний может быть сложным:
обычно неприемлемо блокировать обработчик прерывания, и было бы особо
губительно блокировать его, ожидая, когда главный поток освободит замыкание,
так как в этом случае мы получим _deadlock_ (главный поток никогда не освободит
замыкание, потому что выполнение остается в обработчике прерывания).
Deadlocking не считается небезопасным: он возможен даже в безопасном Rust.

Чтобы полностью избежать такого поведения, мы могли бы реализовать мьютекс,
который требует критическую секцию, чтобы замкнться, точно как в
нашем примере со счетчиком. Пока критическая секция длится столько же,
сколько и блокировка, мы может быть уверены, что имеем эксклюзивный доступ
к обернутой переменной даже не отслеживая состояние мьютекса.

На самом деле это уже сделано для нас в крейте `cortex_m`!
Мы бы могли переписать наш счетчик с его использованием:

```rust,ignore
use core::cell::Cell;
use cortex_m::interrupt::Mutex;

static COUNTER: Mutex<Cell<u32>> = Mutex::new(Cell::new(0));

#[entry]
fn main() -> ! {
    set_timer_1hz();
    let mut last_state = false;
    loop {
        let state = read_signal_level();
        if state && !last_state {
            interrupt::free(|cs|
                COUNTER.borrow(cs).set(COUNTER.borrow(cs).get() + 1));
        }
        last_state = state;
    }
}

#[interrupt]
fn timer() {
    // Нам всё ещё нужно входить в критическую секцию, чтобы проверить Mutex.
    interrupt::free(|cs| COUNTER.borrow(cs).set(0));
}
```

Теперь мы используем  [`Cell`], который вместе со своим братом `RefCell`
используется, чтобы обеспечить безопасную interior mutability.
Мы уже встречались с `UnsafeCell`, который представляет
низкий уровень interior mutability в Rust: он позволяет получить множество
изменяемых ссылок на значение, но только в небезопасном коде. `Cell` - это
как `UnsafeCell`, но предоставляющий безопасный интерфейс: он позволяет только
брать копию текущего значения или заменять его, но не брать ссылку,
поэтому он не Sync и не может передаваться между потоками. Это ограничение
значит, что использовать его безопасно, но мы не может использовать его напрямую в
`static` переменнной, т.к. `static` должна быть Sync.

[`Cell`]: https://doc.rust-lang.org/core/cell/struct.Cell.html

Так почему пример выше работает? `Mutex<T>` реализует Sync для любого
`T`, который Send — такого как `Cell`. Он может делать это безопасно,
потому что дает доступ к содержимому только во время критической секции.
Поэтому мы можем получить безопасный счетчик, полностью избавившись от
небезопасного кода!

Это великолепно для простых типов, таких как `u32` у нашего счетчика,
но что насчет более сложных типов, которые не Copy?
Чрезвычайно распространенным примером в эмбеддед контексте является структура
периферии, которая обычно не Copy.
ля этого мы можем обратиться к `RefCell`.

## Разделяемые периферийные устройства

Крейты устройств, сгенерированные с помощью `svd2rust` и подобные им абстракции
предоставляют безопасный доступ к периферии, проверяя, что одновременно
может существовать только один экземпляр структуры периферии. Это обеспечивает
безопасность, но делает сложным доступ к периферии как из основного потока,
так и обработчика прерывания.

Чтобы безопасно разделить доступ к периферии, мы можем использовать `Mutex`,
который видели рашьше. Нам также нужен будет [`RefCell`], который использует рантайм,
чтобы проверить, что ссылка на периферию одна в каждый момент времени.
Он требует больше накладных расходов, чем простой `Cell`,
но так как мы передаем ссылки, а не копии, то должны убедиться, что существет только одна.

[`RefCell`]: https://doc.rust-lang.org/core/cell/struct.RefCell.html

Наконец, мы должны определить, как  передать периферию в разделяемую переменную
после того, как она была инициализирована в главном коде. Для этого мы можем использовать
тип `Option`, инициализируемый ничем (`None`), а позже поместить в него
экземпляр периферии.

```rust,ignore
use core::cell::RefCell;
use cortex_m::interrupt::{self, Mutex};
use stm32f4::stm32f405;

static MY_GPIO: Mutex<RefCell<Option<stm32f405::GPIOA>>> =
    Mutex::new(RefCell::new(None));

#[entry]
fn main() -> ! {
    // Получить одиночку периферии и настроить её.
    // Этот пример из крейта, сгенерированного svd2rust, но
    // большинство крейтов встраиваемых устройств будут похожими.
    let dp = stm32f405::Peripherals::take().unwrap();
    let gpioa = &dp.GPIOA;

    // Какая-то функция настройки.
    // Предположим она устанавливает PA0 на вход, а PA1 на выход.
    configure_gpio(gpioa);

    // Поместить GPIOA в мьютекс, передать его.
    interrupt::free(|cs| MY_GPIO.borrow(cs).replace(Some(dp.GPIOA)));
    // Больше мы не можем использовать `gpioa` или `dp.GPIOA`,а вместо этого должны
    // получать доступ через мьютекс.

    // Будьте осторожны, включайте прерывание только после установки MY_GPIO:
    // иначе прерывание может возникнуть, когда мьютекс ещё содержит None,
    // и как написано (через `unwrap()`) он вызовет панику.
    set_timer_1hz();
    let mut last_state = false;
    loop {
        // А сейчас прочтем состояние цифрового входа используя мьютекс
        let state = interrupt::free(|cs| {
            let gpioa = MY_GPIO.borrow(cs).borrow();
            gpioa.as_ref().unwrap().idr.read().idr0().bit_is_set()
        });

        if state && !last_state {
            // Установим PA1 в высокое состояние, когда увидим передний фронт на PA0.
            interrupt::free(|cs| {
                let gpioa = MY_GPIO.borrow(cs).borrow();
                gpioa.as_ref().unwrap().odr.modify(|_, w| w.odr1().set_bit());
            });
        }
        last_state = state;
    }
}

#[interrupt]
fn timer() {
    // В это же время прерывание будет просто очищать PA0.
    interrupt::free(|cs| {
        // Мы можем использовать `unwrap()`, потому что знаем, что прерывание не было включено
        // пока не установили MY_GPIO; иначе нам нужно было бы обрабатывать возможное
        // None значение.
        let gpioa = MY_GPIO.borrow(cs).borrow();
        gpioa.as_ref().unwrap().odr.modify(|_, w| w.odr1().clear_bit());
    });
}
```

Тут довольно много, поэтому давайте разберемся с важными строками.

```rust,ignore
static MY_GPIO: Mutex<RefCell<Option<stm32f405::GPIOA>>> =
    Mutex::new(RefCell::new(None));
```

Наши разделяемая переменная теперь `Mutex`, содержащий `RefCell`, содержащий
`Option`. `Mutex` проверяет, что мы имеем доступ только в критической секции,
и превращающий переменную в Sync, даже когда обычный `RefCell` не будет Sync.
`RefCell` даёт нам interior mutability с ссылками, которая нам будет нужна
для использования `GPIOA`. `Option` позволяет нам инициализировать переменную
чем-то пустым, и уже после действительно поместить туда переменную.
Мы не можем получить доступ к одиночке периферии статически, только во время выполнения,
поэтому это необходимо.

```rust,ignore
interrupt::free(|cs| MY_GPIO.borrow(cs).replace(Some(dp.GPIOA)));
```

Внутри критической секции мы можем вызвать `borrow()` на мьютексе, который отдаст нам
ссылку на `RefCell`. Затем мы вызываем `replace()`, чтобы поместить новое значение в `RefCell`.

```rust,ignore
interrupt::free(|cs| {
    let gpioa = MY_GPIO.borrow(cs).borrow();
    gpioa.as_ref().unwrap().odr.modify(|_, w| w.odr1().set_bit());
});
```

Наконец-то мы используем `MY_GPIO` в безопасном конкурентном стиле. Критическая секция
предотвращает появление прерывания и позволяет нам заимствовать мьютекс.
Затем `RefCell` отдает нам `&Option<GPIOA>`, и следит, как долго он остается
заимствован - как только ссылка выходит из области видимости, `RefCell` обновится,
чтобы показать, что он больше не заимствован.

Так как мы не можем перемещать `GPIOA` из `&Option`, нам нужно конвертировать его в 
`&Option<&GPIOA>` с помощью `as_ref()`, который мы можем `unwrap()`, чтобы получить
`&GPIOA`, который позволит нам модиицировать периферию.

Если нам нужны изменяемые ссылки на разделяемый ресурс, тогда вместо них
нужно использовать `borrow_mut` и `deref_mut`. Следующий код показывает
пример с использованием таймера TIM2.

```rust,ignore
use core::cell::RefCell;
use core::ops::DerefMut;
use cortex_m::interrupt::{self, Mutex};
use cortex_m::asm::wfi;
use stm32f4::stm32f405;

static G_TIM: Mutex<RefCell<Option<Timer<stm32::TIM2>>>> =
	Mutex::new(RefCell::new(None));

#[entry]
fn main() -> ! {
    let mut cp = cm::Peripherals::take().unwrap();
    let dp = stm32f405::Peripherals::take().unwrap();

    // Какая-то функция настройки таймера.
    // Предположим она настраивает таймер TIM2, его NVIC прерывание,
    // и в конце запускает таймер.
    let tim = configure_timer_interrupt(&mut cp, dp);

    interrupt::free(|cs| {
        G_TIM.borrow(cs).replace(Some(tim));
    });

    loop {
        wfi();
    }
}

#[interrupt]
fn timer() {
    interrupt::free(|cs| {
        if let Some(ref mut tim)) =  G_TIM.borrow(cs).borrow_mut().deref_mut() {
            tim.start(1.hz());
        }
    });
}

```

> **ПРИМЕЧАНИЕ**
>
> В настоящий момент, крейт `cortex-m` прячет константные версии некоторых функций
> (включая `Mutex::new()`) за опцией `const-fn`. Поэтоиу Вы должны включить опцию
> `const-fn` для зависимости cortex-m в Cargo.toml, чтобы заставить примеры
> выше работать:
>
> ``` toml
> [dependencies.cortex-m]
> version="0.6.0"
> features=["const-fn"]
> ```
> `const-fn` уже работает на стабильно Rust какое-то время.
> Поэтому дополнительные переключения в Cargo.toml будут не нужны, как только
> оно будет в `cortex-m` по умолчанию.
>

Фух! Всё безопасно, но также и немного громоздко. Есть ли что-то другое,
что мы можем использовать?

## RTFM

Одной из альтернатив является [фреймворк RTFM][RTFM], сокращение от Real Time For the Masses.
Он проверяет статические приоритеты и отслеживает доступ к `static mut` переменным
("ресурсам"), чтобы статически убедиться, что доступ к разделяемым ресурсам всегда безопасен,
не требуя требуя накладных расходов на регулярный вход в критические секции и
использование счетчика ссылок (как с `RefCell`). Он также имеет рад преимуществ,
такие как гарантированное отсутствие deadlock'ов и минимальные накладные расходы
как по времени, так и по памяти.

[RTFM]: https://github.com/japaric/cortex-m-rtfm

Фреймворк также включает и другую функциональность, такую как передача сообщений,
которая снижает необходимость в явных разделяемых переменных состояний,
и возможность планирования задач на запуск в назначенное время,
которые можно использовать, чтобы реализовывать периодические задачи. Ознакомьтесь с
[документацией][the documentation] для дополнительной информации!

[the documentation]: https://japaric.github.io/cortex-m-rtfm/book/ru/

## Операционные системы реального времени

Другая широко используемая модель конкурентности в эмбеддед - операционные системы
реального времени (RTOS). Несмотря на то, что сейчас они не очень хорошо изучены в Rust,
они широко используются в традиционной разработке встраиваеміх систем.
Есть и примеры с открытым исходным кодом, такие как [FreeRTOS] и
[ChibiOS]. Эти RTOS предоставляют поддержку запуска множества потоков приложений,
которые делят ЦПУ между собой, либо когда поток отдает контроль (называемая
кооперативной многозадачностью) или основанные на обычном таймере и прерываниях
(вытесняющая многозадачность). RTOS обычно предоставляют мьютексы и другие примитивы синхронизации,
и часто взаимодействуют с аппаратными функциями, такими как DMA.

[FreeRTOS]: https://freertos.org/
[ChibiOS]: http://chibios.org/

В момент написания книги, было немного примеров Rust RTOS, чтобы на них указать,
но это интересная область so watch this space!

## Многоядерные системы

Становится все более распространенным иметь два или более ядер во встраиваемых процессорах
что добавляет дополнительный уровень сложности для конкурентности.
Во всех примерах, использующих критическую секцию (включая `cortex_m::interrupt::Mutex`),
предполагается, что единственным другим потоком выполнения является поток прерываний,
но в многоядерной системе это уже не так.
Вместо этого нам понадобятся примитивы синхронизации,
разработанные для нескольких ядер (также называемые SMP, для симметричной многопроцессорной обработки).

Они обычно используют атомарные инструкции, с которыми мы встречались ранее,
поскольку система обработки будет проверять, что атомарность обеспечивается
во всех ядрах.

Подробное освещение этих тем в настоящее время выходит за рамки этой книги,
но общие закономерности такие же, как и в случае с одноядерным процессором.
